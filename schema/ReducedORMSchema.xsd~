<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="http://tempuri.org/XMLSchema.xsd"
    elementFormDefault="qualified"
    xmlns="http://tempuri.org/XMLSchema.xsd"
    xmlns:mstns="http://tempuri.org/XMLSchema.xsd"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
>

 
  <!-- =============================================================================================================== -->
  <!-- CONSTRAINTS SECTION -->
  <!-- =============================================================================================================== -->
  <xs:complexType name="ConstraintsType">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="EqualityConstraint" type="EqualityConstraintType"/>     <!-- Ignore and report to user -->
      <xs:element name="ExclusionConstraint" type="ExclusionConstraintType"/>   <!-- Ignore and report to user -->
      <xs:element name="SubsetConstraint" type="SubsetConstraintType"/>
      <xs:element name="FrequencyConstraint" type="FrequencyConstraintType"/>
      <xs:element name="MandatoryConstraint" type="MandatoryConstraintType"/>
      <xs:element name="UniquenessConstraint" type="UniquenessConstraintType"/>
      <xs:element name="RingConstraint" type="RingConstraintType"/>             <!-- Ignore and report to user -->
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="ConstraintType" abstract="true">
    <xs:attributeGroup ref="idAttribute"/>
    <xs:attribute name="Name" type="xs:string" use="required"> </xs:attribute> <!-- Unique within model --> 
    <xs:attribute name="Modality" type="ConstraintModalityValues" default="Alethic"/>  <!-- Give user the option whether to ignore deontic? -->
  </xs:complexType>

  <xs:simpleType name="ConstraintModalityValues">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Alethic"></xs:enumeration>
      <xs:enumeration value="Deontic"></xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  
  <xs:complexType name="SetComparisonConstraintType" abstract="true">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="RoleSequences" type="ConstraintRoleSequencesType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequencesType">
    <xs:sequence>
      <xs:element name="RoleSequence" type="ConstraintRoleSequenceWithJoinAndIdType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequenceWithJoinAndIdType">
    <xs:annotation>
      <xs:documentation>A sequence of constraint roles with an identifier.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ConstraintRoleSequenceWithJoinType">
        <xs:attributeGroup ref="idAttribute"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequenceWithJoinType">
    <xs:annotation>
      <xs:documentation>A sequence of constraint roles and possible join path.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Role" type="RoleSequenceWithProjectionRoleRef" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="JoinRule" type="JoinRuleType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="RoleSequenceWithProjectionRoleRef">
    <xs:complexContent>
      <xs:extension base="RoleSequenceRoleRef">
        <xs:sequence>
          <xs:element name="ProjectedFrom" minOccurs="0"> <!-- Deprecated: check for this, but if found, spit out error. -->
            <xs:annotation>
              <xs:documentation>(Deprecated, use JoinPath/JoinPathProjections) The node in the join path used to populate this role in a derived fact type.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0">
                <xs:element name="PathedRole" type="PathedRoleRef"/>
                <xs:element name="CalculatedValue" type="CalculatedValueRef"/>
                <xs:element name="Constant" type="PathConstantType"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RoleSequenceRoleRef">
    <xs:complexContent>
      <xs:extension base="RoleRef">
        <xs:attributeGroup ref="idAttributeOptional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RoleRef">
    <xs:annotation>
      <xs:documentation>A reference to a role.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="refAttribute"/>
  </xs:complexType>

  <xs:complexType name="JoinRuleType">
    <xs:annotation>
      <xs:documentation>A rule indicating how roles from different fact types in the same constraint role sequence are connected.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="JoinPath" type="ConstraintRoleSequenceJoinPathType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequenceJoinPathType">
    <xs:annotation>
      <xs:documentation>A role path used to define the path between roles in different fact types in the same join path.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="RolePathOwnerType">
        <xs:sequence>
          <xs:element name="JoinPathProjections" minOccurs="0"> <!-- A container for different sets of path projections. -->
            <xs:complexType>
              <xs:sequence>
                <xs:element name="JoinPathProjection" type="JoinPathProjectionType" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="IsAutomatic" default="false" type="xs:boolean"> </xs:attribute> <!-- The join path is automatically created from the constraint sequence.-->        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RolePathOwnerType" abstract="true">
    <xs:sequence>
      <xs:choice>
        <xs:element name="PathComponents" minOccurs="0"><!-- A container for the role paths defined for this owner.-->
          <xs:complexType>
            <xs:sequence>
              <xs:element name="RolePath" type="LeadRolePathType" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element name="SharedRolePath" type="LeadRolePathRef" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="PathComponent" minOccurs="0"> <!-- Report UNEXPECTED join format. -->
          <xs:annotation>
            <xs:documentation>(Deprecated, use PathComponents) A container for the role path defined by this owner.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs="0">
              <xs:element name="RolePath" type="LeadRolePathType"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
      <xs:element name="CalculatedValues" minOccurs="0"> <!-- Report UNEXPECTED join path format. -->
        <xs:annotation>
          <xs:documentation>(Deprecated, move to individual path components) A container for calculated values applied to elements in contained role paths.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="CalculatedValue" type="CalculatedValueType" minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="Subqueries" minOccurs="0"> <!-- Report UNEXPECTED join path format. -->
        <xs:annotation>
          <xs:documentation>A container for subquery elements used by paths in this container.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Subquery" type="QueryType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="SharedSubquery" type="SubqueryRef" minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attributeGroup ref="idAttribute"/>
  </xs:complexType>

  <xs:complexType name="LeadRolePathType"> <!-- A role path starting from a root object type.-->
   <xs:complexContent>
      <xs:extension base="RolePathType">
        <xs:sequence>
          <xs:element name="ObjectUnifiers" minOccurs="0">
            <xs:annotation>
              <xs:documentation>A container for object unifiers relating multiple pathed roles and pathed roots in difference branches of the path.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="ObjectUnifier" type="ObjectUnifierType" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="SubqueryParameterInputs" minOccurs="0">
            <xs:annotation>
              <xs:documentation>A container for subquery parameter inputs relating pathed roles and pathed roots with parameters used in subqueries used directly by this path.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="SubqueryParameterInputsFor" type="SubqueryParameterInputsForType" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="CalculatedValues" minOccurs="0">
            <xs:annotation>
              <xs:documentation>A container for calculated values applied to any elements in this role path.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="CalculatedValue" type="CalculatedValueType" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="Conditions" minOccurs="0">
            <xs:annotation>
              <xs:documentation>A list of calculated boolean results that are necessary conditions for this role path.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="CalculatedCondition" type="CalculatedValueRef" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="Notes" type="NotesType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RolePathType" abstract="true">
    <xs:choice maxOccurs="2">
      <!-- UNDONE: The choice here is a temporary hack to allow a RootObjectType to appear either before or after the PathedRoles and SubPaths,
			as with older file formats. The RootObjectType is always saved first with the current format. -->
      <xs:element name="RootObjectType" minOccurs="0" type="RootObjectTypeType"/>
      <xs:sequence minOccurs="0">
        <xs:element name="PathedRoles" minOccurs="0">
          <xs:annotation>
            <xs:documentation>A container for PathedRole elements.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="PathedRole" type="PathedRoleType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="SubPaths" minOccurs="0">
          <xs:annotation>
            <xs:documentation>A container for SubPath elements.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="SubPath" type="RoleSubPathType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:choice>
    <xs:attributeGroup ref="idAttribute"/>
    <xs:attribute name="SplitIsNegated" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>Should a negation be applied to the split combination operator?</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="SplitCombinationOperator" type="LogicalCombinationOperatorType" default="And">
      <xs:annotation>
        <xs:documentation>Specify how sub paths split from this path should be combined.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  
  <xs:complexType name="LeadRolePathRef">
    <xs:annotation>
      <xs:documentation>A reference to a top-level role path.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="refAttribute"/>
  </xs:complexType>
  
  <!-- =============================================================================================================== -->

  <xs:complexType name="SubsetConstraintType">
    <xs:complexContent>
      <xs:extension base="SetComparisonConstraintType">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="FrequencyConstraintType">
     <xs:complexContent>
      <xs:extension base="SetConstraintWithJoinType">
        <xs:attribute name="MinFrequency" type="xs:int"><!-- The minimum number of times an instance must be played by the constrained role(s).--></xs:attribute>
        <xs:attribute name="MaxFrequency" type="xs:int"><!-- The maximum number of times an instance must be played by the constrained role(s).--></xs:attribute>
      </xs:extension >
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="SetConstraintType" abstract="true">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="RoleSequence" type="ConstraintRoleSequenceType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequenceType">
    <xs:annotation>
      <xs:documentation>A sequence of constraint roles.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Role" type="RoleSequenceRoleRef" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  
  <xs:complexType name="SetConstraintWithJoinType" abstract="true">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="RoleSequence" type="ConstraintRoleSequenceWithJoinType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="MandatoryConstraintType">
     <xs:complexContent>
      <xs:extension base="SetConstraintType">
        <xs:sequence>
          <xs:element name="ExclusiveOrExclusionConstraint" type="ExclusionConstraintRef" minOccurs="0"/> <!-- If populated, ignore and report to user -->
        </xs:sequence>
        <xs:attribute name="IsSimple" type="xs:boolean" default="false">  <!-- If false, report to user as ignored constraint -->
          <xs:annotation>
            <xs:documentation>True if this is an internal constraint associated with a single role.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="UniquenessConstraintType">
    <xs:annotation>
      <xs:documentation>A constraint specifying that the population of a set must be unique.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="SetConstraintWithJoinType">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
</xs:schema>
