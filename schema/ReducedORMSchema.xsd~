<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="http://tempuri.org/XMLSchema.xsd"
    elementFormDefault="qualified"
    xmlns="http://tempuri.org/XMLSchema.xsd"
    xmlns:mstns="http://tempuri.org/XMLSchema.xsd"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
>
  <!-- MJN: This file is a subset of ORM2Core.xsd provided with NORMA (Copyright ORM Solutions LLC) -->
  <!-- MJN: We are only interested in the ORMModel element in a .ORM file -->

  <!-- =============================================================================================================== -->
  <!-- ORMMODEL SECTION -->
  <!-- =============================================================================================================== -->

  <xs:element name="ORMModel" type="ORMModelType"/>
  <xs:complexType name="ORMModelType">
    <xs:annotation>
      <xs:documentation>Definition of elements used in the primary definition of an ORM model.</xs:documentation>
    </xs:annotation>
    <xs:all>
      <xs:element name="Objects" type="ObjectTypesType" minOccurs="0"/>
      <xs:element name="Facts" type="FactTypesType" minOccurs="0"/>
      <xs:element name="Constraints" type="ConstraintsType" minOccurs="0"/>
      <xs:element name="DataTypes" type="DataTypesType" minOccurs="0"/> <!-- MJN: Value types have conceptual data types that REF these data types.  -->
    </xs:all>
  </xs:complexType>

 
  <!-- =============================================================================================================== -->

 <ValueRestriction>
    <ValueConstraint id="" name="">
        <ValueRanges>
            <!-- MinValue and MaxValue are required and are strings --> 
            <!-- MinInclusion and MaxInclusion indiciate whether the range includes the bound.  They
                 default to "NotSet" but can also be "Open" or "Closed" -->
            <!-- ValueRange can also include the attributes , 
                 which are for culture-invariant forms, but I don't understand how to use these. -->
            <ValueRange id="" MinValue="" MaxValue="" MinInclusion="" MaxInclusion="">
            </ValueRange>
            .
            .
            .
            <ValueRange>
            </ValueRange>
        </ValueRanges>
    </ValueConstraint>
 </ValueRestriction>

 
  <!-- =============================================================================================================== -->
  <!-- FACT TYPES SECTION -->
  <!-- =============================================================================================================== -->
  <xs:complexType name="FactTypesType">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="Fact" type="FactTypeType"/>
      <xs:element name="SubtypeFact" type="SubtypeFactTypeType"/>  <!-- This is how NORMA indicates a subtype constraint -->
      
      <!-- <xs:element name="ImpliedFact" type="ImpliedFactTypeType"/> This is used for the implied fact types of an objectification.  90% sure I don't need -->
    </xs:choice>
  </xs:complexType>
  
  <xs:complexType name="FactTypeType"> <!-- Directly specified by the modeler -->
    <xs:sequence minOccurs="0">
      <xs:element name="FactRoles" type="FactRolesType" minOccurs="0"/>
      
      <xs:element name="DerivationRule" type="FactTypeDerivationRuleType" minOccurs="0"/> <!-- Do not load.  Report to user that derivation is ignored. -->
    </xs:sequence>
    <xs:attribute name="_Name" type="xs:string"></xs:attribute> <!-- Generated from first reading of first reading order or from objectifying entity -->    
    <xs:attributeGroup ref="idAttribute"/>
  </xs:complexType>

  <xs:complexType name="FactRolesType"> <!-- Container for roles -->
     <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="Role" type="RoleType"/>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="RoleType">
    <xs:complexContent>
      <xs:extension base="RoleBaseType">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RoleBaseType" abstract="true">
    <xs:sequence>
      <xs:element name="RolePlayer" type="ObjectTypeRef" minOccurs="0"> </xs:element> <!-- Ref to Object Type that plays the role -->    
      <xs:element name="ValueRestriction" type="RoleValueRestrictionType" minOccurs="0"/>

      <xs:element name="DerivationSource" minOccurs="0"></xs:element><!-- Do not load.  Report to user that derivation is ignored. -->
    </xs:sequence>
    <xs:attribute name="Name" type="xs:string"> </xs:attribute> <!-- Explicit name for the role -->
    <xs:attributeGroup ref="idAttribute"/>
  </xs:complexType>

  <xs:complexType name="ObjectTypeRef">
    <xs:attributeGroup ref="refAttribute"/>
  </xs:complexType>

  <xs:complexType name="RoleValueRestrictionType">
    <xs:sequence>
      <xs:element name="RoleValueConstraint" type="ValueConstraintWithNameType"/>
    </xs:sequence>
  </xs:complexType>
  
  <xs:complexType name="SubtypeFactTypeType"> <!-- Used to indicate subtype relationship -->
    <xs:sequence minOccurs="0">
      <xs:element name="FactRoles" type="SubtypeRolesType"/>
    </xs:sequence>
    <xs:attribute name="_Name" type="xs:string"></xs:attribute> <!-- E.g. AIsASubtypeOfB -->
    <xs:attributeGroup ref="idAttribute"/>
    
    <!-- NOT CLEAR IF I NEED THESE...BECAUSE I DON"T UNDERSTAND WHAT THEY ARE FOR! -->
            <xs:attribute name="IsPrimary" type="xs:boolean" default="false">
              <xs:annotation>
                <!-- UNDONE: Remove IsPrimary when file format is officially updated -->
                <xs:documentation>Deprecated property, use PreferredIdentificationPath instead.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="PreferredIdentificationPath" type="xs:boolean" default="false">
              <xs:annotation>
                <xs:documentation>The subtype fact is a possible path through the subtype graph for retrieving the identifying supertype for the subtype. The identifying supertype can be a direct or indirect supertype.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
    <!-- END NOT CLEAR -->
  </xs:complexType>

  <xs:complexType name="SubtypeRolesType">
    <xs:annotation>
      <xs:documentation>Container for the meta roles associated with a subtype fact.</xs:documentation>
    </xs:annotation>
    <xs:all>
      <xs:element name="SupertypeMetaRole" type="RoleType">
        <xs:annotation>
          <xs:documentation>The meta role associated with the supertype role player.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="SubtypeMetaRole" type="RoleType">
        <xs:annotation>
          <xs:documentation>The meta role associated with the subtype role player.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:all>
  </xs:complexType>


  
  <!-- =============================================================================================================== -->
  <!-- CONSTRAINTS SECTION -->
  <!-- =============================================================================================================== -->
  <xs:complexType name="ConstraintsType">
    <xs:annotation>
      <xs:documentation>Container for SetConstraints and SetComparisonConstraints.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="EqualityConstraint" type="EqualityConstraintType"/>     <!-- Ignore and report to user -->
      <xs:element name="ExclusionConstraint" type="ExclusionConstraintType"/>   <!-- Ignore and report to user -->
      <xs:element name="SubsetConstraint" type="SubsetConstraintType"/>
      <xs:element name="FrequencyConstraint" type="FrequencyConstraintType"/>
      <xs:element name="MandatoryConstraint" type="MandatoryConstraintType"/>
      <xs:element name="UniquenessConstraint" type="UniquenessConstraintType"/>
      <xs:element name="RingConstraint" type="RingConstraintType"/>             <!-- Ignore and report to user -->
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="ConstraintType" abstract="true">
    <xs:attributeGroup ref="idAttribute"/>
    <xs:attribute name="Name" type="xs:string" use="required"> </xs:attribute> <!-- Unique within model --> 
    <xs:attribute name="Modality" type="ConstraintModalityValues" default="Alethic"/>  <!-- Give user the option whether to ignore deontic? -->
  </xs:complexType>

  <xs:simpleType name="ConstraintModalityValues">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Alethic"></xs:enumeration>
      <xs:enumeration value="Deontic"></xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  
  <xs:complexType name="SetComparisonConstraintType" abstract="true">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="RoleSequences" type="ConstraintRoleSequencesType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequencesType">
    <xs:sequence>
      <xs:element name="RoleSequence" type="ConstraintRoleSequenceWithJoinAndIdType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequenceWithJoinAndIdType">
    <xs:annotation>
      <xs:documentation>A sequence of constraint roles with an identifier.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ConstraintRoleSequenceWithJoinType">
        <xs:attributeGroup ref="idAttribute"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequenceWithJoinType">
    <xs:annotation>
      <xs:documentation>A sequence of constraint roles and possible join path.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Role" type="RoleSequenceWithProjectionRoleRef" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="JoinRule" type="JoinRuleType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="RoleSequenceWithProjectionRoleRef">
    <xs:complexContent>
      <xs:extension base="RoleSequenceRoleRef">
        <xs:sequence>
          <xs:element name="ProjectedFrom" minOccurs="0"> <!-- Deprecated: check for this, but if found, spit out error. -->
            <xs:annotation>
              <xs:documentation>(Deprecated, use JoinPath/JoinPathProjections) The node in the join path used to populate this role in a derived fact type.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0">
                <xs:element name="PathedRole" type="PathedRoleRef"/>
                <xs:element name="CalculatedValue" type="CalculatedValueRef"/>
                <xs:element name="Constant" type="PathConstantType"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RoleSequenceRoleRef">
    <xs:complexContent>
      <xs:extension base="RoleRef">
        <xs:attributeGroup ref="idAttributeOptional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RoleRef">
    <xs:annotation>
      <xs:documentation>A reference to a role.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="refAttribute"/>
  </xs:complexType>

  <xs:complexType name="JoinRuleType">
    <xs:annotation>
      <xs:documentation>A rule indicating how roles from different fact types in the same constraint role sequence are connected.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="JoinPath" type="ConstraintRoleSequenceJoinPathType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequenceJoinPathType">
    <xs:annotation>
      <xs:documentation>A role path used to define the path between roles in different fact types in the same join path.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="RolePathOwnerType">
        <xs:sequence>
          <xs:element name="JoinPathProjections" minOccurs="0"> <!-- A container for different sets of path projections. -->
            <xs:complexType>
              <xs:sequence>
                <xs:element name="JoinPathProjection" type="JoinPathProjectionType" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="IsAutomatic" default="false" type="xs:boolean"> </xs:attribute> <!-- The join path is automatically created from the constraint sequence.-->        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RolePathOwnerType" abstract="true">
    <xs:sequence>
      <xs:choice>
        <xs:element name="PathComponents" minOccurs="0"><!-- A container for the role paths defined for this owner.-->
          <xs:complexType>
            <xs:sequence>
              <xs:element name="RolePath" type="LeadRolePathType" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element name="SharedRolePath" type="LeadRolePathRef" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="PathComponent" minOccurs="0"> <!-- Report UNEXPECTED join format. -->
          <xs:annotation>
            <xs:documentation>(Deprecated, use PathComponents) A container for the role path defined by this owner.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs="0">
              <xs:element name="RolePath" type="LeadRolePathType"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
      <xs:element name="CalculatedValues" minOccurs="0"> <!-- Report UNEXPECTED join path format. -->
        <xs:annotation>
          <xs:documentation>(Deprecated, move to individual path components) A container for calculated values applied to elements in contained role paths.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="CalculatedValue" type="CalculatedValueType" minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="Subqueries" minOccurs="0"> <!-- Report UNEXPECTED join path format. -->
        <xs:annotation>
          <xs:documentation>A container for subquery elements used by paths in this container.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Subquery" type="QueryType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="SharedSubquery" type="SubqueryRef" minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attributeGroup ref="idAttribute"/>
  </xs:complexType>

  <xs:complexType name="LeadRolePathType"> <!-- A role path starting from a root object type.-->
   <xs:complexContent>
      <xs:extension base="RolePathType">
        <xs:sequence>
          <xs:element name="ObjectUnifiers" minOccurs="0">
            <xs:annotation>
              <xs:documentation>A container for object unifiers relating multiple pathed roles and pathed roots in difference branches of the path.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="ObjectUnifier" type="ObjectUnifierType" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="SubqueryParameterInputs" minOccurs="0">
            <xs:annotation>
              <xs:documentation>A container for subquery parameter inputs relating pathed roles and pathed roots with parameters used in subqueries used directly by this path.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="SubqueryParameterInputsFor" type="SubqueryParameterInputsForType" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="CalculatedValues" minOccurs="0">
            <xs:annotation>
              <xs:documentation>A container for calculated values applied to any elements in this role path.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="CalculatedValue" type="CalculatedValueType" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="Conditions" minOccurs="0">
            <xs:annotation>
              <xs:documentation>A list of calculated boolean results that are necessary conditions for this role path.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="CalculatedCondition" type="CalculatedValueRef" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="Notes" type="NotesType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RolePathType" abstract="true">
    <xs:choice maxOccurs="2">
      <!-- UNDONE: The choice here is a temporary hack to allow a RootObjectType to appear either before or after the PathedRoles and SubPaths,
			as with older file formats. The RootObjectType is always saved first with the current format. -->
      <xs:element name="RootObjectType" minOccurs="0" type="RootObjectTypeType"/>
      <xs:sequence minOccurs="0">
        <xs:element name="PathedRoles" minOccurs="0">
          <xs:annotation>
            <xs:documentation>A container for PathedRole elements.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="PathedRole" type="PathedRoleType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="SubPaths" minOccurs="0">
          <xs:annotation>
            <xs:documentation>A container for SubPath elements.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="SubPath" type="RoleSubPathType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:choice>
    <xs:attributeGroup ref="idAttribute"/>
    <xs:attribute name="SplitIsNegated" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>Should a negation be applied to the split combination operator?</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="SplitCombinationOperator" type="LogicalCombinationOperatorType" default="And">
      <xs:annotation>
        <xs:documentation>Specify how sub paths split from this path should be combined.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  
  <xs:complexType name="LeadRolePathRef">
    <xs:annotation>
      <xs:documentation>A reference to a top-level role path.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="refAttribute"/>
  </xs:complexType>
  
  <!-- =============================================================================================================== -->

  <xs:complexType name="SubsetConstraintType">
    <xs:complexContent>
      <xs:extension base="SetComparisonConstraintType">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="FrequencyConstraintType">
     <xs:complexContent>
      <xs:extension base="SetConstraintWithJoinType">
        <xs:attribute name="MinFrequency" type="xs:int"><!-- The minimum number of times an instance must be played by the constrained role(s).--></xs:attribute>
        <xs:attribute name="MaxFrequency" type="xs:int"><!-- The maximum number of times an instance must be played by the constrained role(s).--></xs:attribute>
      </xs:extension >
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="SetConstraintType" abstract="true">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="RoleSequence" type="ConstraintRoleSequenceType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ConstraintRoleSequenceType">
    <xs:annotation>
      <xs:documentation>A sequence of constraint roles.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Role" type="RoleSequenceRoleRef" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  
  <xs:complexType name="SetConstraintWithJoinType" abstract="true">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="RoleSequence" type="ConstraintRoleSequenceWithJoinType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="MandatoryConstraintType">
     <xs:complexContent>
      <xs:extension base="SetConstraintType">
        <xs:sequence>
          <xs:element name="ExclusiveOrExclusionConstraint" type="ExclusionConstraintRef" minOccurs="0"/> <!-- If populated, ignore and report to user -->
        </xs:sequence>
        <xs:attribute name="IsSimple" type="xs:boolean" default="false">  <!-- If false, report to user as ignored constraint -->
          <xs:annotation>
            <xs:documentation>True if this is an internal constraint associated with a single role.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="UniquenessConstraintType">
    <xs:annotation>
      <xs:documentation>A constraint specifying that the population of a set must be unique.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="SetConstraintWithJoinType">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
</xs:schema>
